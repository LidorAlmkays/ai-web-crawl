# Job 4.3: Kafka Integration Testing

## Objective

Comprehensive integration testing of Kafka message processing to ensure all message types are handled correctly with proper validation and error handling.

## Problem Analysis

After implementing J3 (Enum Values), we need to verify that:

- All Kafka message types are processed correctly
- Enum values are validated properly
- Message validation works correctly
- Error handling is robust
- End-to-end message flows work

## Solution

### Implementation

**File**: `src/api/kafka/__tests__/integration.spec.ts`

```typescript
import { KafkaRouter } from '../kafka.router';
import { TaskStatus } from '../../../common/enums/task-status.enum';
import { NewTaskStatusMessageDto } from '../dtos/new-task-status-message.dto';
import { CompletedTaskStatusMessageDto } from '../dtos/completed-task-status-message.dto';
import { ErrorTaskStatusMessageDto } from '../dtos/error-task-status-message.dto';

describe('Kafka Integration Tests', () => {
  let kafkaRouter: KafkaRouter;

  beforeEach(() => {
    kafkaRouter = new KafkaRouter();
  });

  describe('Message Processing', () => {
    it('should process new task message', async () => {
      const message: NewTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.NOT_COMPLETED,
        createdAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(message);
      }).not.toThrow();
    });

    it('should process completed task message', async () => {
      const message: CompletedTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.COMPLETED_SUCCESS,
        result: { data: 'test result' },
        completedAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processCompletedTaskMessage(message);
      }).not.toThrow();
    });

    it('should process error task message', async () => {
      const message: ErrorTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.COMPLETED_ERROR,
        errorMessage: 'Test error',
        errorAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processErrorTaskMessage(message);
      }).not.toThrow();
    });
  });

  describe('Message Validation', () => {
    it('should reject invalid enum values', () => {
      const invalidMessage = {
        taskId: 'test-task-123',
        status: 'invalid_status', // Invalid enum value
        createdAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(invalidMessage as any);
      }).toThrow();
    });

    it('should reject missing required fields', () => {
      const invalidMessage = {
        taskId: 'test-task-123',
        // Missing status and createdAt
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(invalidMessage as any);
      }).toThrow();
    });

    it('should reject invalid task ID format', () => {
      const invalidMessage = {
        taskId: 'invalid-uuid',
        status: TaskStatus.NOT_COMPLETED,
        createdAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(invalidMessage as any);
      }).toThrow();
    });

    it('should reject invalid date format', () => {
      const invalidMessage = {
        taskId: 'test-task-123',
        status: TaskStatus.NOT_COMPLETED,
        createdAt: 'invalid-date',
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(invalidMessage as any);
      }).toThrow();
    });
  });

  describe('Enum Value Handling', () => {
    it('should accept all valid task status values', () => {
      const validStatuses = [TaskStatus.NOT_COMPLETED, TaskStatus.COMPLETED_SUCCESS, TaskStatus.COMPLETED_ERROR];

      validStatuses.forEach((status) => {
        const message = {
          taskId: 'test-task-123',
          status,
          createdAt: new Date().toISOString(),
        };

        expect(() => {
          kafkaRouter.processNewTaskMessage(message as any);
        }).not.toThrow();
      });
    });

    it('should reject old enum values', () => {
      const oldStatuses = ['new', 'complete', 'error'];

      oldStatuses.forEach((status) => {
        const message = {
          taskId: 'test-task-123',
          status,
          createdAt: new Date().toISOString(),
        };

        expect(() => {
          kafkaRouter.processNewTaskMessage(message as any);
        }).toThrow();
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle malformed JSON', () => {
      const malformedMessage = '{"taskId": "test-123", "status": "not_completed"}'; // Missing quotes

      expect(() => {
        kafkaRouter.processNewTaskMessage(JSON.parse(malformedMessage) as any);
      }).toThrow();
    });

    it('should handle null message', () => {
      expect(() => {
        kafkaRouter.processNewTaskMessage(null as any);
      }).toThrow();
    });

    it('should handle undefined message', () => {
      expect(() => {
        kafkaRouter.processNewTaskMessage(undefined as any);
      }).toThrow();
    });

    it('should handle empty message object', () => {
      expect(() => {
        kafkaRouter.processNewTaskMessage({} as any);
      }).toThrow();
    });
  });

  describe('End-to-End Message Flow', () => {
    it('should handle complete task lifecycle through messages', () => {
      // 1. New task message
      const newTaskMessage: NewTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.NOT_COMPLETED,
        createdAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(newTaskMessage);
      }).not.toThrow();

      // 2. Completed task message
      const completedTaskMessage: CompletedTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.COMPLETED_SUCCESS,
        result: { data: 'test result' },
        completedAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processCompletedTaskMessage(completedTaskMessage);
      }).not.toThrow();
    });

    it('should handle error task lifecycle through messages', () => {
      // 1. New task message
      const newTaskMessage: NewTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.NOT_COMPLETED,
        createdAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processNewTaskMessage(newTaskMessage);
      }).not.toThrow();

      // 2. Error task message
      const errorTaskMessage: ErrorTaskStatusMessageDto = {
        taskId: 'test-task-123',
        status: TaskStatus.COMPLETED_ERROR,
        errorMessage: 'Test error occurred',
        errorAt: new Date().toISOString(),
      };

      expect(() => {
        kafkaRouter.processErrorTaskMessage(errorTaskMessage);
      }).not.toThrow();
    });
  });

  describe('Performance Testing', () => {
    it('should handle high message volume', () => {
      const messages = [];
      for (let i = 0; i < 100; i++) {
        messages.push({
          taskId: `test-task-${i}`,
          status: TaskStatus.NOT_COMPLETED,
          createdAt: new Date().toISOString(),
        });
      }

      const startTime = Date.now();
      messages.forEach((message) => {
        kafkaRouter.processNewTaskMessage(message as any);
      });
      const endTime = Date.now();

      expect(endTime - startTime).toBeLessThan(1000); // Should process 100 messages in under 1 second
    });
  });
});
```

## Implementation Steps

### Step 1: Setup Test Environment

1. Configure Kafka test environment
2. Setup message validation testing
3. Setup error scenario testing

### Step 2: Create Integration Tests

1. Test all message types
2. Test message validation
3. Test enum value handling
4. Test error scenarios

### Step 3: Test Message Flows

1. Test complete task lifecycle
2. Test error task lifecycle
3. Test concurrent message processing
4. Test performance under load

### Step 4: Test Validation

1. Test DTO validation
2. Test enum validation
3. Test required field validation
4. Test format validation

## Success Criteria

- [ ] All message types are processed correctly
- [ ] Enum values are validated properly
- [ ] Message validation works correctly
- [ ] Error handling is robust
- [ ] End-to-end message flows work
- [ ] Performance is acceptable
- [ ] All tests pass

## Testing Strategy

### Unit Tests

- Test individual message processors
- Test validation logic
- Test error handling

### Integration Tests

- Test with Kafka infrastructure
- Test message flows
- Test concurrent processing

### Validation Tests

- Test DTO validation
- Test enum validation
- Test format validation

## Dependencies

- J3 (Enum Values) completed
- Kafka test environment
- Message validation setup

## Risks and Mitigation

### Risks

1. **Kafka Infrastructure**: Kafka might not be available for testing
2. **Message Ordering**: Messages might be processed out of order
3. **Validation Issues**: Message validation might be too strict or too loose
4. **Performance Issues**: High message volume might cause performance problems

### Mitigation

1. **Kafka Mocking**: Mock Kafka infrastructure for testing
2. **Message Ordering**: Test message ordering scenarios
3. **Validation Testing**: Thorough validation testing
4. **Performance Testing**: Load testing with realistic scenarios
