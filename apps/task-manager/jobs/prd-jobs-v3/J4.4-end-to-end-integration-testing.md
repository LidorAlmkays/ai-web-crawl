# Job 4.4: End-to-End Integration Testing

## Objective

Comprehensive end-to-end integration testing to ensure all components work together correctly in complete workflows and user scenarios.

## Problem Analysis

After implementing J1, J2, and J3, we need to verify that:

- Complete task lifecycle works end-to-end
- All components integrate properly
- Logging works throughout the application
- Database operations work with real data
- Error scenarios are handled correctly
- Performance is acceptable under load

## Solution

### Implementation

**File**: `src/__tests__/e2e-integration.spec.ts`

```typescript
import { WebCrawlTaskManagerService } from '../application/services/web-crawl-task-manager.service';
import { WebCrawlTaskRepositoryAdapter } from '../infrastructure/persistence/postgres/adapters/web-crawl-task.repository.adapter';
import { TaskStatus } from '../common/enums/task-status.enum';
import { PostgresFactory } from '../infrastructure/persistence/postgres/postgres.factory';
import { logger } from '../common/utils/logger';

describe('End-to-End Integration Tests', () => {
  let service: WebCrawlTaskManagerService;
  let repository: WebCrawlTaskRepositoryAdapter;
  let client: any;

  beforeAll(async () => {
    client = await PostgresFactory.createClient();
    repository = new WebCrawlTaskRepositoryAdapter(client);
    service = new WebCrawlTaskManagerService(repository);
  });

  afterAll(async () => {
    await client.end();
  });

  beforeEach(async () => {
    // Clean up test data
    await client.query('DELETE FROM web_crawl_tasks WHERE user_email LIKE $1', ['test%']);
  });

  describe('Complete Task Lifecycle', () => {
    it('should handle complete task lifecycle with logging', async () => {
      // 1. Create task
      logger.info('Starting task creation');
      const task = await service.createTask('test@example.com', 'https://example.com');

      expect(task.status).toBe(TaskStatus.NOT_COMPLETED);
      logger.success('Task created successfully', { taskId: task.id });

      // 2. Mark as completed
      logger.info('Marking task as completed');
      const completedTask = await service.markTaskAsCompleted(task.id, { data: 'test result' });

      expect(completedTask.status).toBe(TaskStatus.COMPLETED_SUCCESS);
      expect(completedTask.result).toEqual({ data: 'test result' });
      logger.success('Task completed successfully', { taskId: task.id });

      // 3. Verify in database
      const foundTask = await repository.findWebCrawlTaskById(task.id);
      expect(foundTask).toBeDefined();
      expect(foundTask?.status).toBe(TaskStatus.COMPLETED_SUCCESS);
      logger.info('Task verified in database', { taskId: task.id });
    });

    it('should handle error task lifecycle', async () => {
      // 1. Create task
      const task = await service.createTask('test@example.com', 'https://example.com');

      // 2. Mark as error
      logger.info('Marking task as error');
      const errorTask = await service.markTaskAsError(task.id, 'Test error occurred');

      expect(errorTask.status).toBe(TaskStatus.COMPLETED_ERROR);
      expect(errorTask.result).toEqual({ error: 'Test error occurred' });
      logger.error('Task marked as error', { taskId: task.id, error: 'Test error occurred' });

      // 3. Verify in database
      const foundTask = await repository.findWebCrawlTaskById(task.id);
      expect(foundTask?.status).toBe(TaskStatus.COMPLETED_ERROR);
    });
  });

  describe('Concurrent Operations', () => {
    it('should handle concurrent task operations', async () => {
      const promises = [];

      // Create multiple tasks concurrently
      for (let i = 0; i < 5; i++) {
        promises.push(service.createTask(`test${i}@example.com`, `https://example${i}.com`));
      }

      const tasks = await Promise.all(promises);
      expect(tasks).toHaveLength(5);

      // Update tasks concurrently
      const updatePromises = tasks.map((task, index) => service.markTaskAsCompleted(task.id, { data: `result-${index}` }));

      const updatedTasks = await Promise.all(updatePromises);
      expect(updatedTasks.every((task) => task.status === TaskStatus.COMPLETED_SUCCESS)).toBe(true);
    });

    it('should handle concurrent reads and writes', async () => {
      // Create a task
      const task = await service.createTask('test@example.com', 'https://example.com');

      // Concurrent read and write operations
      const readPromise = repository.findWebCrawlTaskById(task.id);
      const updatePromise = service.markTaskAsCompleted(task.id, { data: 'concurrent result' });

      const [foundTask, updatedTask] = await Promise.all([readPromise, updatePromise]);

      expect(foundTask).toBeDefined();
      expect(updatedTask.status).toBe(TaskStatus.COMPLETED_SUCCESS);
    });
  });

  describe('Error Scenarios', () => {
    it('should handle database connection errors gracefully', async () => {
      // Test with invalid database configuration
      // This would require mocking the database connection
      expect(() => {
        // Simulate database error
        throw new Error('Database connection failed');
      }).toThrow('Database connection failed');
    });

    it('should handle invalid task operations', async () => {
      // Try to update non-existent task
      await expect(service.markTaskAsCompleted('00000000-0000-0000-0000-000000000000', { data: 'test' })).rejects.toThrow();
    });

    it('should handle invalid input data', async () => {
      // Try to create task with invalid email
      await expect(service.createTask('invalid-email', 'https://example.com')).rejects.toThrow();
    });
  });

  describe('Performance Testing', () => {
    it('should handle high load operations', async () => {
      const startTime = Date.now();

      // Create 50 tasks
      const createPromises = [];
      for (let i = 0; i < 50; i++) {
        createPromises.push(service.createTask(`test${i}@example.com`, `https://example${i}.com`));
      }

      const tasks = await Promise.all(createPromises);
      expect(tasks).toHaveLength(50);

      // Update all tasks
      const updatePromises = tasks.map((task, index) => service.markTaskAsCompleted(task.id, { data: `result-${index}` }));

      const updatedTasks = await Promise.all(updatePromises);
      expect(updatedTasks.every((task) => task.status === TaskStatus.COMPLETED_SUCCESS)).toBe(true);

      const endTime = Date.now();
      const duration = endTime - startTime;

      // Should complete in reasonable time (adjust based on system capabilities)
      expect(duration).toBeLessThan(10000); // 10 seconds
    });

    it('should maintain performance under concurrent load', async () => {
      const concurrentUsers = 10;
      const operationsPerUser = 5;

      const userPromises = [];
      for (let user = 0; user < concurrentUsers; user++) {
        const userOperations = [];
        for (let op = 0; op < operationsPerUser; op++) {
          userOperations.push(service.createTask(`user${user}@example.com`, `https://example${user}-${op}.com`));
        }
        userPromises.push(Promise.all(userOperations));
      }

      const startTime = Date.now();
      const allResults = await Promise.all(userPromises);
      const endTime = Date.now();

      const totalTasks = allResults.flat().length;
      expect(totalTasks).toBe(concurrentUsers * operationsPerUser);

      const duration = endTime - startTime;
      expect(duration).toBeLessThan(15000); // 15 seconds
    });
  });

  describe('Data Integrity', () => {
    it('should maintain data consistency across operations', async () => {
      // Create task
      const task = await service.createTask('test@example.com', 'https://example.com');

      // Verify initial state
      let foundTask = await repository.findWebCrawlTaskById(task.id);
      expect(foundTask?.status).toBe(TaskStatus.NOT_COMPLETED);

      // Update task
      await service.markTaskAsCompleted(task.id, { data: 'test result' });

      // Verify updated state
      foundTask = await repository.findWebCrawlTaskById(task.id);
      expect(foundTask?.status).toBe(TaskStatus.COMPLETED_SUCCESS);
      expect(foundTask?.result).toEqual({ data: 'test result' });

      // Verify task count
      const pendingCount = await repository.countWebCrawlTasksByStatus(TaskStatus.NOT_COMPLETED);
      const completedCount = await repository.countWebCrawlTasksByStatus(TaskStatus.COMPLETED_SUCCESS);
      const totalCount = await repository.countAllWebCrawlTasks();

      expect(totalCount).toBe(pendingCount + completedCount);
    });

    it('should handle transaction rollback on errors', async () => {
      // This would require testing with actual database transactions
      // and simulating rollback scenarios
    });
  });

  describe('Logging Integration', () => {
    it('should log all operations correctly', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      // Perform operations
      const task = await service.createTask('test@example.com', 'https://example.com');
      await service.markTaskAsCompleted(task.id, { data: 'test result' });

      // Verify logging occurred
      expect(consoleSpy).toHaveBeenCalled();

      consoleSpy.mockRestore();
    });

    it('should include proper metadata in logs', async () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const task = await service.createTask('test@example.com', 'https://example.com');

      // Verify log contains task ID
      const calls = consoleSpy.mock.calls;
      const logMessages = calls.map((call) => call[0]).join(' ');
      expect(logMessages).toContain(task.id);

      consoleSpy.mockRestore();
    });
  });
});
```

## Implementation Steps

### Step 1: Setup Test Environment

1. Configure complete test environment
2. Setup database with test data
3. Configure logging for testing
4. Setup performance monitoring

### Step 2: Create End-to-End Tests

1. Test complete task lifecycle
2. Test concurrent operations
3. Test error scenarios
4. Test performance under load

### Step 3: Test Data Integrity

1. Test data consistency
2. Test transaction handling
3. Test rollback scenarios
4. Test data validation

### Step 4: Test Performance

1. Test high load scenarios
2. Test concurrent operations
3. Test response times
4. Test resource usage

## Success Criteria

- [ ] Complete task lifecycle works end-to-end
- [ ] All components integrate properly
- [ ] Logging works throughout the application
- [ ] Database operations work with real data
- [ ] Error scenarios are handled correctly
- [ ] Performance is acceptable under load
- [ ] Data integrity is maintained
- [ ] All tests pass

## Testing Strategy

### Integration Tests

- Test component interactions
- Test data flow
- Test error handling

### Performance Tests

- Test under load
- Test concurrent operations
- Test response times

### Data Integrity Tests

- Test data consistency
- Test transaction handling
- Test rollback scenarios

## Dependencies

- All previous jobs completed (J1, J2, J3)
- Complete test environment setup
- Performance monitoring tools

## Risks and Mitigation

### Risks

1. **Test Complexity**: End-to-end tests might be complex and flaky
2. **Performance Issues**: Tests might be slow
3. **Resource Usage**: Tests might consume too many resources
4. **Data Pollution**: Tests might affect each other

### Mitigation

1. **Test Isolation**: Proper test isolation and cleanup
2. **Performance Optimization**: Optimize test execution
3. **Resource Management**: Monitor and limit resource usage
4. **Data Management**: Proper test data management
