# Job 4.1: Database Integration Testing

## Objective

Comprehensive integration testing of database operations to ensure all CRUD operations work correctly with stored procedures and proper error handling.

## Problem Analysis

After implementing J1 (Database Queries), we need to verify that:

- All stored procedure calls work correctly
- Parameter binding is handled properly
- Error scenarios are handled gracefully
- Concurrent operations work correctly
- Data integrity is maintained

## Solution

### Implementation

**File**: `src/infrastructure/persistence/postgres/__tests__/integration.spec.ts`

```typescript
import { WebCrawlTaskRepositoryAdapter } from '../adapters/web-crawl-task.repository.adapter';
import { TaskStatus } from '../../../../common/enums/task-status.enum';
import { PostgresFactory } from '../postgres.factory';

describe('Database Integration Tests', () => {
  let repository: WebCrawlTaskRepositoryAdapter;
  let client: any;

  beforeAll(async () => {
    client = await PostgresFactory.createClient();
    repository = new WebCrawlTaskRepositoryAdapter(client);
  });

  afterAll(async () => {
    await client.end();
  });

  beforeEach(async () => {
    // Clean up test data
    await client.query('DELETE FROM web_crawl_tasks WHERE user_email LIKE $1', ['test%']);
  });

  describe('Task Lifecycle', () => {
    it('should complete full task lifecycle', async () => {
      // 1. Create task
      const task = await repository.createWebCrawlTask('test@example.com', 'https://example.com', TaskStatus.NOT_COMPLETED, new Date(), new Date());

      expect(task.status).toBe(TaskStatus.NOT_COMPLETED);
      expect(task.userEmail).toBe('test@example.com');

      // 2. Update to completed success
      const completedTask = await repository.updateWebCrawlTask(task.id, {
        status: TaskStatus.COMPLETED_SUCCESS,
        result: { data: 'test result' },
      });

      expect(completedTask?.status).toBe(TaskStatus.COMPLETED_SUCCESS);
      expect(completedTask?.result).toEqual({ data: 'test result' });

      // 3. Verify task can be found
      const foundTask = await repository.findWebCrawlTaskById(task.id);
      expect(foundTask).toBeDefined();
      expect(foundTask?.status).toBe(TaskStatus.COMPLETED_SUCCESS);
    });

    it('should handle task error lifecycle', async () => {
      // 1. Create task
      const task = await repository.createWebCrawlTask('test@example.com', 'https://example.com', TaskStatus.NOT_COMPLETED, new Date(), new Date());

      // 2. Update to error
      const errorTask = await repository.updateWebCrawlTask(task.id, {
        status: TaskStatus.COMPLETED_ERROR,
        result: { error: 'test error' },
      });

      expect(errorTask?.status).toBe(TaskStatus.COMPLETED_ERROR);
      expect(errorTask?.result).toEqual({ error: 'test error' });
    });
  });

  describe('Query Operations', () => {
    it('should find tasks by status', async () => {
      // Create multiple tasks with different statuses
      await repository.createWebCrawlTask('test1@example.com', 'https://example1.com', TaskStatus.NOT_COMPLETED, new Date(), new Date());
      await repository.createWebCrawlTask('test2@example.com', 'https://example2.com', TaskStatus.COMPLETED_SUCCESS, new Date(), new Date());

      const pendingTasks = await repository.findWebCrawlTasksByStatus(TaskStatus.NOT_COMPLETED);
      const completedTasks = await repository.findWebCrawlTasksByStatus(TaskStatus.COMPLETED_SUCCESS);

      expect(pendingTasks.length).toBeGreaterThan(0);
      expect(completedTasks.length).toBeGreaterThan(0);
    });

    it('should find tasks by user email', async () => {
      await repository.createWebCrawlTask('test@example.com', 'https://example1.com', TaskStatus.NOT_COMPLETED, new Date(), new Date());
      await repository.createWebCrawlTask('test@example.com', 'https://example2.com', TaskStatus.COMPLETED_SUCCESS, new Date(), new Date());

      const userTasks = await repository.findWebCrawlTasksByUserEmail('test@example.com');
      expect(userTasks.length).toBeGreaterThan(0);
      expect(userTasks.every((task) => task.userEmail === 'test@example.com')).toBe(true);
    });

    it('should count tasks correctly', async () => {
      await repository.createWebCrawlTask('test@example.com', 'https://example.com', TaskStatus.NOT_COMPLETED, new Date(), new Date());

      const pendingCount = await repository.countWebCrawlTasksByStatus(TaskStatus.NOT_COMPLETED);
      const totalCount = await repository.countAllWebCrawlTasks();

      expect(pendingCount).toBeGreaterThan(0);
      expect(totalCount).toBeGreaterThan(0);
    });
  });

  describe('Error Scenarios', () => {
    it('should handle invalid task ID', async () => {
      const result = await repository.findWebCrawlTaskById('invalid-uuid');
      expect(result).toBeNull();
    });

    it('should handle non-existent task update', async () => {
      const result = await repository.updateWebCrawlTask('00000000-0000-0000-0000-000000000000', {
        status: TaskStatus.COMPLETED_SUCCESS,
      });
      expect(result).toBeNull();
    });

    it('should handle database connection errors', async () => {
      // Test with invalid database configuration
      // This would require mocking the database connection
    });
  });

  describe('Concurrent Operations', () => {
    it('should handle concurrent task creation', async () => {
      const promises = [];
      for (let i = 0; i < 5; i++) {
        promises.push(repository.createWebCrawlTask(`test${i}@example.com`, `https://example${i}.com`, TaskStatus.NOT_COMPLETED, new Date(), new Date()));
      }

      const tasks = await Promise.all(promises);
      expect(tasks).toHaveLength(5);
      expect(tasks.every((task) => task.status === TaskStatus.NOT_COMPLETED)).toBe(true);
    });

    it('should handle concurrent task updates', async () => {
      // Create a single task
      const task = await repository.createWebCrawlTask('test@example.com', 'https://example.com', TaskStatus.NOT_COMPLETED, new Date(), new Date());

      // Update it concurrently multiple times
      const promises = [];
      for (let i = 0; i < 3; i++) {
        promises.push(
          repository.updateWebCrawlTask(task.id, {
            result: { data: `result-${i}` },
          })
        );
      }

      const results = await Promise.all(promises);
      expect(results.every((result) => result !== null)).toBe(true);
    });
  });
});
```

## Implementation Steps

### Step 1: Setup Test Environment

1. Configure test database connection
2. Create test data cleanup procedures
3. Setup test isolation mechanisms

### Step 2: Create Integration Tests

1. Test task lifecycle (create, update, read)
2. Test query operations (find by status, email, count)
3. Test error scenarios
4. Test concurrent operations

### Step 3: Test Stored Procedures

1. Verify all stored procedures exist
2. Test parameter binding
3. Test return values
4. Test error handling

### Step 4: Performance Testing

1. Test with large datasets
2. Test concurrent operations
3. Test response times
4. Test resource usage

## Success Criteria

- [ ] All CRUD operations work correctly
- [ ] Stored procedures are called correctly
- [ ] Parameter binding works properly
- [ ] Error scenarios are handled gracefully
- [ ] Concurrent operations work correctly
- [ ] Data integrity is maintained
- [ ] Performance is acceptable
- [ ] All tests pass

## Testing Strategy

### Unit Tests

- Test individual repository methods
- Mock database client
- Test error scenarios

### Integration Tests

- Test with real database
- Test stored procedure calls
- Test data persistence

### Performance Tests

- Test concurrent operations
- Test with large datasets
- Test response times

## Dependencies

- J1 (Database Queries) completed
- Test database setup
- PostgreSQL with stored procedures

## Risks and Mitigation

### Risks

1. **Test Data Pollution**: Tests might affect each other
2. **Database State**: Database might be in unexpected state
3. **Performance Issues**: Tests might be slow
4. **Concurrent Issues**: Race conditions in tests

### Mitigation

1. **Test Isolation**: Proper cleanup between tests
2. **Database Reset**: Reset database state before tests
3. **Test Optimization**: Optimize test execution
4. **Concurrent Testing**: Proper handling of concurrent operations
