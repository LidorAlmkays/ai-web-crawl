# Job 2.4: Create Logger Factory and Update Main Logger

## Objective

Create a logger factory that can switch between different logger implementations and update the main logger to use the factory pattern.

## Problem Analysis

Need a factory pattern that:

- Can switch between simple, structured, and OTel loggers
- Uses environment variables for configuration
- Provides a unified interface
- Maintains backward compatibility
- Supports singleton pattern

## Solution

### Implementation

**File**: `src/common/utils/logger-factory.ts`

```typescript
import { SimpleLogger, SimpleLoggerImpl } from './simple-logger';
import { StructuredLogger, StructuredLoggerImpl } from './structured-logger';
import { OtelLogger, OtelLoggerImpl } from './otel-logger';

export interface ILogger {
  error(message: string, meta?: any): void;
  info(message: string, meta?: any): void;
  debug(message: string, meta?: any): void;
  success(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  setTraceContext?(traceId: string, spanId: string): void;
}

export class LoggerFactory {
  private static instance: ILogger;

  static getLogger(): ILogger {
    if (!LoggerFactory.instance) {
      const logFormat = process.env.LOG_FORMAT || 'simple';

      switch (logFormat) {
        case 'simple':
          LoggerFactory.instance = new SimpleLoggerImpl();
          break;
        case 'structured':
          LoggerFactory.instance = new StructuredLoggerImpl();
          break;
        case 'otel':
          LoggerFactory.instance = new OtelLoggerImpl();
          break;
        default:
          LoggerFactory.instance = new SimpleLoggerImpl();
      }
    }

    return LoggerFactory.instance;
  }

  static resetLogger(): void {
    LoggerFactory.instance = undefined as any;
  }
}
```

**File**: `src/common/utils/logger.ts`

```typescript
import { LoggerFactory, ILogger } from './logger-factory';

// Export the logger instance
export const logger: ILogger = LoggerFactory.getLogger();

// Convenience methods for backward compatibility
export const logInfo = (message: string, meta?: any) => logger.info(message, meta);
export const logError = (message: string, meta?: any) => logger.error(message, meta);
export const logWarn = (message: string, meta?: any): void => logger.warn(message, meta);
export const logDebug = (message: string, meta?: any): void => logger.debug(message, meta);
export const logSuccess = (message: string, meta?: any): void => logger.success(message, meta);

// OTEL-specific convenience method
export const setTraceContext = (traceId: string, spanId: string): void => {
  if (logger.setTraceContext) {
    logger.setTraceContext(traceId, spanId);
  }
};
```

## Implementation Steps

### Step 1: Create Logger Factory

1. Create `src/common/utils/logger-factory.ts`
2. Define `ILogger` interface
3. Implement `LoggerFactory` class with singleton pattern
4. Add logger switching logic based on environment variable

### Step 2: Update Main Logger

1. Update `src/common/utils/logger.ts`
2. Import and use `LoggerFactory`
3. Export logger instance
4. Add convenience methods for backward compatibility
5. Add OTEL-specific convenience method

### Step 3: Environment Configuration

```bash
# Logging Configuration
LOG_FORMAT=simple  # 'simple', 'structured', or 'otel'
LOG_LEVEL=debug
```

### Step 4: Testing

1. Test logger factory with different formats
2. Test singleton pattern
3. Test environment variable switching
4. Test backward compatibility methods
5. Test OTEL trace context method

## Success Criteria

- [ ] Logger factory can switch between all three logger types
- [ ] Environment variable controls logger selection
- [ ] Singleton pattern works correctly
- [ ] Backward compatibility methods function
- [ ] OTEL trace context method works
- [ ] Unit tests pass
- [ ] No breaking changes to existing code

## Example Usage

```typescript
// Using the factory directly
import { LoggerFactory } from './logger-factory';

const logger = LoggerFactory.getLogger();
logger.info('Test message');

// Using convenience methods
import { logInfo, logError } from './logger';

logInfo('Test info message');
logError('Test error message');

// Using OTEL trace context
import { setTraceContext } from './logger';

setTraceContext('trace-123', 'span-456');
```

## Testing

### Unit Tests

```typescript
describe('LoggerFactory', () => {
  beforeEach(() => {
    LoggerFactory.resetLogger();
  });

  it('should create simple logger by default', () => {
    const logger = LoggerFactory.getLogger();
    expect(logger).toBeInstanceOf(SimpleLoggerImpl);
  });

  it('should create structured logger when LOG_FORMAT=structured', () => {
    process.env.LOG_FORMAT = 'structured';
    const logger = LoggerFactory.getLogger();
    expect(logger).toBeInstanceOf(StructuredLoggerImpl);
  });

  it('should create OTel logger when LOG_FORMAT=otel', () => {
    process.env.LOG_FORMAT = 'otel';
    const logger = LoggerFactory.getLogger();
    expect(logger).toBeInstanceOf(OtelLoggerImpl);
  });

  it('should maintain singleton pattern', () => {
    const logger1 = LoggerFactory.getLogger();
    const logger2 = LoggerFactory.getLogger();
    expect(logger1).toBe(logger2);
  });
});

describe('Logger convenience methods', () => {
  it('should call logger methods correctly', () => {
    const mockLogger = {
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn(),
      success: jest.fn(),
    };

    // Mock the factory to return our mock logger
    jest.spyOn(LoggerFactory, 'getLogger').mockReturnValue(mockLogger as any);

    logInfo('test info');
    logError('test error');
    logWarn('test warn');
    logDebug('test debug');
    logSuccess('test success');

    expect(mockLogger.info).toHaveBeenCalledWith('test info');
    expect(mockLogger.error).toHaveBeenCalledWith('test error');
    expect(mockLogger.warn).toHaveBeenCalledWith('test warn');
    expect(mockLogger.debug).toHaveBeenCalledWith('test debug');
    expect(mockLogger.success).toHaveBeenCalledWith('test success');
  });
});
```

## Dependencies

- All three logger implementations (J2.1, J2.2, J2.3)
- Environment variable configuration

## Environment Variables

```bash
# Logging Configuration
LOG_FORMAT=simple  # 'simple', 'structured', or 'otel'
LOG_LEVEL=debug
```

## Risks and Mitigation

### Risks

1. **Circular Dependencies**: Factory might create circular imports
2. **Environment Variable Issues**: LOG_FORMAT might not be set correctly
3. **Singleton Issues**: Multiple instances might be created
4. **Backward Compatibility**: Existing code might break

### Mitigation

1. **Import Structure**: Careful import organization to avoid circular dependencies
2. **Default Values**: Provide sensible defaults for environment variables
3. **Singleton Testing**: Thorough testing of singleton pattern
4. **Compatibility Testing**: Test all existing code with new factory
