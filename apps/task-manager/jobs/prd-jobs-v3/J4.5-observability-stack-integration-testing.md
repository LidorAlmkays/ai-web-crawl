# Job 4.5: Observability Stack Integration Testing

## Objective

Comprehensive integration testing of the observability stack to ensure all components (OTEL Collector, Jaeger, Prometheus, Loki, Grafana) work together correctly and can receive and display application data.

## Problem Analysis

After implementing J2 (Enhanced Logging System), we need to verify that:

- OTEL Collector can receive telemetry data
- Jaeger can display traces
- Prometheus can collect metrics
- Loki can aggregate logs
- Grafana can visualize all data
- All services can communicate with each other

## Solution

### Implementation

**File**: `deployment/observability/__tests__/stack-integration.spec.ts`

```typescript
import axios from 'axios';

describe('Observability Stack Integration Tests', () => {
  describe('OTEL Collector', () => {
    it('should accept telemetry data', async () => {
      const response = await axios.post('http://localhost:4318/v1/traces', {
        resourceSpans: [
          {
            resource: {
              attributes: [
                {
                  key: 'service.name',
                  value: { stringValue: 'task-manager' },
                },
              ],
            },
            scopeSpans: [
              {
                spans: [
                  {
                    traceId: 'test-trace-id',
                    spanId: 'test-span-id',
                    name: 'test-span',
                    startTimeUnixNano: Date.now() * 1000000,
                    endTimeUnixNano: Date.now() * 1000000,
                  },
                ],
              },
            ],
          },
        ],
      });

      expect(response.status).toBe(200);
    });

    it('should accept metrics data', async () => {
      const response = await axios.post('http://localhost:4318/v1/metrics', {
        resourceMetrics: [
          {
            resource: {
              attributes: [
                {
                  key: 'service.name',
                  value: { stringValue: 'task-manager' },
                },
              ],
            },
            scopeMetrics: [
              {
                metrics: [
                  {
                    name: 'test_metric',
                    unit: 'count',
                    sum: {
                      dataPoints: [
                        {
                          timeUnixNano: Date.now() * 1000000,
                          value: 1,
                        },
                      ],
                    },
                  },
                ],
              },
            ],
          },
        ],
      });

      expect(response.status).toBe(200);
    });

    it('should accept logs data', async () => {
      const response = await axios.post('http://localhost:4318/v1/logs', {
        resourceLogs: [
          {
            resource: {
              attributes: [
                {
                  key: 'service.name',
                  value: { stringValue: 'task-manager' },
                },
              ],
            },
            scopeLogs: [
              {
                logRecords: [
                  {
                    timeUnixNano: Date.now() * 1000000,
                    severityText: 'INFO',
                    body: { stringValue: 'Test log message' },
                  },
                ],
              },
            ],
          },
        ],
      });

      expect(response.status).toBe(200);
    });
  });

  describe('Jaeger', () => {
    it('should be accessible', async () => {
      const response = await axios.get('http://localhost:16686/api/services');
      expect(response.status).toBe(200);
    });

    it('should list services', async () => {
      const response = await axios.get('http://localhost:16686/api/services');
      expect(response.data).toBeDefined();
      expect(Array.isArray(response.data.data)).toBe(true);
    });

    it('should accept traces', async () => {
      const response = await axios.post('http://localhost:14268/api/traces', [
        {
          traceId: 'test-trace-id',
          spans: [
            {
              traceId: 'test-trace-id',
              spanId: 'test-span-id',
              operationName: 'test-operation',
              startTime: Date.now() * 1000,
              duration: 1000,
            },
          ],
        },
      ]);

      expect(response.status).toBe(202);
    });
  });

  describe('Prometheus', () => {
    it('should be accessible', async () => {
      const response = await axios.get('http://localhost:9090/api/v1/status/config');
      expect(response.status).toBe(200);
    });

    it('should scrape targets', async () => {
      const response = await axios.get('http://localhost:9090/api/v1/targets');
      expect(response.status).toBe(200);
      expect(response.data.data.activeTargets).toBeDefined();
    });

    it('should have task-manager metrics', async () => {
      const response = await axios.get('http://localhost:9090/api/v1/query?query=task_manager_tasks_total');
      expect(response.status).toBe(200);
      expect(response.data.data.result).toBeDefined();
    });
  });

  describe('Loki', () => {
    it('should be accessible', async () => {
      const response = await axios.get('http://localhost:3100/ready');
      expect(response.status).toBe(200);
    });

    it('should accept logs', async () => {
      const response = await axios.post('http://localhost:3100/loki/api/v1/push', {
        streams: [
          {
            stream: {
              job: 'task-manager',
              level: 'info',
            },
            values: [[Date.now() * 1000000, 'Test log message']],
          },
        ],
      });

      expect(response.status).toBe(204);
    });

    it('should query logs', async () => {
      const response = await axios.get('http://localhost:3100/loki/api/v1/query_range?query={job="task-manager"}&start=0&end=' + Date.now());
      expect(response.status).toBe(200);
      expect(response.data.data.result).toBeDefined();
    });
  });

  describe('Grafana', () => {
    it('should be accessible', async () => {
      const response = await axios.get('http://localhost:3000/api/health');
      expect(response.status).toBe(200);
    });

    it('should have datasources configured', async () => {
      const response = await axios.get('http://localhost:3000/api/datasources', {
        auth: {
          username: 'admin',
          password: 'admin',
        },
      });
      expect(response.status).toBe(200);
      expect(response.data).toBeDefined();
    });

    it('should have dashboards', async () => {
      const response = await axios.get('http://localhost:3000/api/search', {
        auth: {
          username: 'admin',
          password: 'admin',
        },
      });
      expect(response.status).toBe(200);
      expect(response.data).toBeDefined();
    });
  });

  describe('End-to-End Data Flow', () => {
    it('should send data from application to observability stack', async () => {
      // This test would require the application to be running and sending data
      // to the observability stack

      // 1. Send trace data
      await axios.post('http://localhost:4318/v1/traces', {
        resourceSpans: [
          {
            resource: {
              attributes: [
                {
                  key: 'service.name',
                  value: { stringValue: 'task-manager' },
                },
              ],
            },
            scopeSpans: [
              {
                spans: [
                  {
                    traceId: 'e2e-trace-id',
                    spanId: 'e2e-span-id',
                    name: 'task-creation',
                    startTimeUnixNano: Date.now() * 1000000,
                    endTimeUnixNano: Date.now() * 1000000,
                  },
                ],
              },
            ],
          },
        ],
      });

      // 2. Send metric data
      await axios.post('http://localhost:4318/v1/metrics', {
        resourceMetrics: [
          {
            resource: {
              attributes: [
                {
                  key: 'service.name',
                  value: { stringValue: 'task-manager' },
                },
              ],
            },
            scopeMetrics: [
              {
                metrics: [
                  {
                    name: 'task_manager_tasks_total',
                    unit: 'count',
                    sum: {
                      dataPoints: [
                        {
                          timeUnixNano: Date.now() * 1000000,
                          value: 1,
                        },
                      ],
                    },
                  },
                ],
              },
            ],
          },
        ],
      });

      // 3. Send log data
      await axios.post('http://localhost:4318/v1/logs', {
        resourceLogs: [
          {
            resource: {
              attributes: [
                {
                  key: 'service.name',
                  value: { stringValue: 'task-manager' },
                },
              ],
            },
            scopeLogs: [
              {
                logRecords: [
                  {
                    timeUnixNano: Date.now() * 1000000,
                    severityText: 'INFO',
                    body: { stringValue: 'Task created successfully' },
                  },
                ],
              },
            ],
          },
        ],
      });

      // 4. Verify data is available in Grafana
      // This would require checking Grafana APIs to verify data is visible
    });

    it('should display data in Grafana dashboards', async () => {
      // Test that Grafana can query and display data from all datasources

      // Test Prometheus datasource
      const prometheusResponse = await axios.get('http://localhost:3000/api/datasources/proxy/1/api/v1/query?query=up', {
        auth: {
          username: 'admin',
          password: 'admin',
        },
      });
      expect(prometheusResponse.status).toBe(200);

      // Test Loki datasource
      const lokiResponse = await axios.get('http://localhost:3000/api/datasources/proxy/2/loki/api/v1/query_range?query={job="task-manager"}&start=0&end=' + Date.now(), {
        auth: {
          username: 'admin',
          password: 'admin',
        },
      });
      expect(lokiResponse.status).toBe(200);
    });
  });

  describe('Performance Testing', () => {
    it('should handle high volume of telemetry data', async () => {
      const startTime = Date.now();
      const promises = [];

      // Send 100 trace records
      for (let i = 0; i < 100; i++) {
        promises.push(
          axios.post('http://localhost:4318/v1/traces', {
            resourceSpans: [
              {
                resource: {
                  attributes: [
                    {
                      key: 'service.name',
                      value: { stringValue: 'task-manager' },
                    },
                  ],
                },
                scopeSpans: [
                  {
                    spans: [
                      {
                        traceId: `trace-${i}`,
                        spanId: `span-${i}`,
                        name: `operation-${i}`,
                        startTimeUnixNano: Date.now() * 1000000,
                        endTimeUnixNano: Date.now() * 1000000,
                      },
                    ],
                  },
                ],
              },
            ],
          })
        );
      }

      const responses = await Promise.all(promises);
      const endTime = Date.now();

      expect(responses.every((r) => r.status === 200)).toBe(true);
      expect(endTime - startTime).toBeLessThan(10000); // Should complete in under 10 seconds
    });
  });
});
```

## Implementation Steps

### Step 1: Setup Observability Stack

1. Start all observability services
2. Verify all services are running
3. Configure inter-service communication
4. Setup test data

### Step 2: Create Integration Tests

1. Test OTEL Collector endpoints
2. Test Jaeger trace collection
3. Test Prometheus metrics collection
4. Test Loki log aggregation
5. Test Grafana visualization

### Step 3: Test Data Flow

1. Test end-to-end data flow
2. Test data persistence
3. Test data retrieval
4. Test data visualization

### Step 4: Test Performance

1. Test high volume data ingestion
2. Test query performance
3. Test dashboard responsiveness
4. Test resource usage

## Success Criteria

- [ ] OTEL Collector can receive telemetry data
- [ ] Jaeger can display traces
- [ ] Prometheus can collect metrics
- [ ] Loki can aggregate logs
- [ ] Grafana can visualize all data
- [ ] All services can communicate with each other
- [ ] End-to-end data flow works
- [ ] Performance is acceptable
- [ ] All tests pass

## Testing Strategy

### Integration Tests

- Test service connectivity
- Test data flow
- Test error handling

### Performance Tests

- Test data ingestion
- Test query performance
- Test resource usage

### End-to-End Tests

- Test complete data flow
- Test visualization
- Test user scenarios

## Dependencies

- J2 (Enhanced Logging System) completed
- Observability stack running
- Application sending telemetry data

## Risks and Mitigation

### Risks

1. **Service Dependencies**: Services might not be available
2. **Data Loss**: Data might be lost in transit
3. **Performance Issues**: High volume might cause issues
4. **Configuration Errors**: Services might be misconfigured

### Mitigation

1. **Service Health Checks**: Regular health checks
2. **Data Validation**: Verify data integrity
3. **Performance Monitoring**: Monitor performance metrics
4. **Configuration Testing**: Test all configurations
