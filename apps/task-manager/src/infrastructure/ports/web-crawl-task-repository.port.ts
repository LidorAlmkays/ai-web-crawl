import { WebCrawlTask } from '../../domain/entities/web-crawl-task.entity';

/**
 * Web Crawl Task Repository Port Interface
 *
 * Defines the contract for web crawl task persistence operations.
 * This interface is implemented by concrete repository adapters
 * and used by the application layer for database operations.
 *
 * This port follows the Repository pattern and Clean Architecture principles,
 * providing a clean abstraction for data persistence operations. It defines
 * all the operations that can be performed on WebCrawlTask entities without
 * exposing database-specific details to the application layer.
 *
 * The interface is implemented by infrastructure adapters (e.g., PostgreSQL)
 * and used by application services for data access.
 */
export interface IWebCrawlTaskRepositoryPort {
  /**
   * Creates a new web crawl task record in the database
   *
   * The ID is generated by the database. Implementations should insert
   * without providing an ID and return the created row populated with the
   * generated ID and timestamps.
   *
   * @param userEmail - Email address of the user
   * @param userQuery - Query/instruction for the crawl
   * @param originalUrl - Original URL to crawl
   * @param receivedAt - Timestamp when the message was received
   * @returns Promise resolving to the created task entity
   * @throws Error - If the task cannot be created
   */
  createWebCrawlTask(
    userEmail: string,
    userQuery: string,
    originalUrl: string,
    receivedAt: Date
  ): Promise<WebCrawlTask>;

  /**
   * Updates an existing web crawl task with new status and result data
   *
   * This method updates a WebCrawlTask domain entity in the underlying
   * data store. The implementation should handle status transitions
   * and ensure data consistency.
   *
   * @param task - The updated domain entity
   * @returns Promise resolving to the updated task entity
   * @throws Error - If the task does not exist or cannot be updated
   *
   * @example
   * ```typescript
   * task.markAsCompleted('Found 5 products');
   * const updatedTask = await repository.updateWebCrawlTask(task);
   * ```
   */
  updateWebCrawlTask(task: WebCrawlTask): Promise<WebCrawlTask>;

  /**
   * Retrieves a web crawl task by its unique identifier
   *
   * This method queries the underlying data store to find a specific
   * task by its ID. Returns null if no task is found.
   *
   * @param id - The task ID to search for
   * @returns Promise resolving to the task entity or null if not found
   *
   * @example
   * ```typescript
   * const task = await repository.findWebCrawlTaskById('task-123');
   * if (task) {
   *   console.log(`Task status: ${task.status}`);
   * }
   * ```
   */
  findWebCrawlTaskById(id: string): Promise<WebCrawlTask | null>;

  /**
   * Finds web crawl tasks by status
   *
   * This method queries the underlying data store to find all tasks
   * with a specific status. The status parameter should match the
   * TaskStatus enum values.
   *
   * @param status - The task status to filter by
   * @returns Promise resolving to an array of tasks with the specified status
   *
   * @example
   * ```typescript
   * const completedTasks = await repository.findWebCrawlTasksByStatus('completed');
   * console.log(`Found ${completedTasks.length} completed tasks`);
   * ```
   */
  findWebCrawlTasksByStatus(status: string): Promise<WebCrawlTask[]>;





  /**
   * Counts web crawl tasks by status
   *
   * This method queries the underlying data store to count the number
   * of tasks with a specific status, useful for statistics and monitoring.
   *
   * @param status - The task status to count
   * @returns Promise resolving to the number of tasks with the specified status
   *
   * @example
   * ```typescript
   * const completedCount = await repository.countWebCrawlTasksByStatus('completed');
   * console.log(`There are ${completedCount} completed tasks`);
   * ```
   */
  countWebCrawlTasksByStatus(status: string): Promise<number>;


}
